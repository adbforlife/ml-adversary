from __future__ import absolute_import, division, print_function, unicode_literals
import numpy as np
from IPython.display import clear_output
from matplotlib import pyplot as plt
from art import config
from art.estimators.classification import BlackBoxClassifier
from art.attacks.evasion import HopSkipJump
from art.utils import to_categorical
from art.utils import load_dataset, get_file, compute_accuracy
import io
import os
# Imports the Google Cloud client library
from google.cloud import vision
from PIL import Image, ImageOps
from matplotlib import cm

# Instantiates a client
os.environ["GOOGLE_APPLICATION_CREDENTIALS"] = "/home/adb/CMU/s21/10701/depth1/google-key.json"
client = vision.ImageAnnotatorClient()

#(x_train, y_train), (x_test, y_test), min_, max_ = load_dataset(str('mnist'))

# Sample predict function that reformats inputs, connects to wml scoring endpoint and
# returns one-hot encoded predictions
curr_path = "/home/adb/CMU/s21/10701/depth1/adversarial-robustness-toolbox/"

# We assign classes {0=Traffic light, 1=Stop sign, 2=neither}
num_queries = 0
def predict(x):
    global num_queries
    num_queries += 1
    print(f"classifier query {num_queries}")
    # Translate array to image
    x = np.array(x)
    y = np.reshape(x, (400,400,3)).astype(np.uint8)
    im = Image.fromarray(y)
    # Get the image in bytes
    img_byte_arr = io.BytesIO()
    im.save(img_byte_arr, format='PNG')
    bs = img_byte_arr.getvalue()
    # Querying google cloud service
    image = vision.Image(content=bs)
    resp = client.label_detection(image=image)
    labels = resp.label_annotations
    # Give label predictions
    prob1 = prob2 = prob3 = 0
    for l in labels:
        if l.description == "Traffic light":
            prob1 = l.score
        elif l.description == "Stop sign":
            prob2 = l.score
    if prob1 == 0 and prob2 == 0:
        return to_categorical([2], nb_classes=3)
    elif prob1 > prob2:
        return to_categorical([0], nb_classes=3)
    else:
        return to_categorical([1], nb_classes=3)


# Create blackbox object
target = Image.open(curr_path + "../traffic.jpg")
target = np.array([np.array(target)])
x_train = target.astype(float)
classifier = BlackBoxClassifier(predict, x_train[0].shape, 3, clip_values=(0, 255))
res = predict(x_train[:1])
assert(res[0,0] == 1))

# Select target image and show prediction
target_image = x_train[0]
#plt.imshow(np.reshape(target_image.astype(np.float32), (400, 400, 3)))
#plt.show(block=False)
res = classifier.predict(x_train[:1])
print(res)
print('Prediction from API is: ' + str(np.argmax(res, axis=1)[0]))

# Generate HopSkipJump attack against black box classifier
attack = HopSkipJump(classifier=classifier, targeted=True, max_iter=0, max_eval=1000, init_eval=10)
iter_step = 10
stop = Image.open(curr_path + "../stop.jpg")
stop = np.array([np.array(stop)]).astype(float)
x_adv = stop
for i in range(3):
    x_adv = attack.generate(x=np.array([target_image]), y=[1], x_adv_init=x_adv)

    print("Adversarial image at step %d." % (i * iter_step), "L2 error",
          np.linalg.norm(np.reshape(x_adv[0] - target_image, [-1])),
          "and class label %d." % np.argmax(classifier.predict(x_adv)[0]))
    im = Image.fromarray(np.reshape(x_adv[0].astype(np.uint8), (400, 400, 3)))
    im.show()
    im.save(curr_path + f"../ims/step{i}.png")
    #plt.imshow(np.reshape(x_adv[0].astype(np.float32), (400, 400)))
    #plt.show(block=False)

    attack.max_iter = iter_step



